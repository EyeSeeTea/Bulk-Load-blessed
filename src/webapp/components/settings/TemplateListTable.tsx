import React, { useState } from "react";
import {
    ConfirmationDialog,
    ObjectsTable,
    PaginationOptions,
    SearchBox,
    TableAction,
    TableColumn,
    TableSelection,
    TableState,
    useLoading,
    useSnackbar,
} from "@eyeseetea/d2-ui-components";
import { Button, Icon, makeStyles } from "@material-ui/core";
import _ from "lodash";
import moment from "moment";

import i18n from "../../../locales";
import { RouteComponentProps } from "../../pages/Router";
import { promiseMap } from "../../../utils/promises";
import { CustomTemplate } from "../../../domain/entities/Template";
import { firstOrFail, isValueInUnionType } from "../../../types/utils";
import { TemplatePermissionsDialog } from "./TemplatePermissionsDialog";
import { useAppContext } from "../../contexts/app-context";
import { FormMode, CustomTemplateEditDialog } from "./TemplateEditDialog";
import { downloadFile } from "../../utils/download";
import { DataForm, DataFormType, dataFormTypes, getTranslations } from "../../../domain/entities/DataForm";
import { fromBase64, xlsxMimeType } from "../../../utils/files";
import { useDataForms } from "../../hooks/useDataForms";
import { Select, SelectProps } from "../select/Select";
import { getGeneratedTemplateId } from "../../logic/sheetBuilder";

interface WarningDialog {
    title?: string;
    description?: string;
    action?: () => void;
}

export interface TemplateRow {
    id: string;
    name: string;
    type: "custom" | "autogenerated";
    description: string;
    created: string;
    lastUpdated: string;
    isDefault: boolean;
    dataFormName: string;
    dataFormId: string;
    dataFormType: DataFormType;
    showLanguage: boolean;
    showPeriod: boolean;
}

type TemplateListTableProps = Pick<
    RouteComponentProps,
    "settings" | "setSettings" | "customTemplates" | "setCustomTemplates"
>;

export default function TemplateListTable(props: TemplateListTableProps) {
    const { settings, setSettings, customTemplates, setCustomTemplates } = props;
    const { api, compositionRoot } = useAppContext();
    const { currentUser } = settings;
    const snackbar = useSnackbar();
    const loading = useLoading();

    const [selection, setSelection] = useState<TableSelection[]>([]);
    const [customTemplateEdit, setCustomTemplateEdit] = useState<FormMode | undefined>();
    const [warningDialog, setWarningDialog] = useState<WarningDialog | null>(null);

    const dataForms = useDataForms();
    const dataFormsById = React.useMemo(() => _.keyBy(dataForms, df => df.id), [dataForms]);

    const allRows = React.useMemo(() => {
        return buildCustomTemplateRow(dataFormsById, customTemplates);
    }, [dataFormsById, customTemplates]);

    const { rows, searchText, search, dataFormTypeOptions, dataFormType, setDataFormTypeFromOption } =
        useFilters(allRows);

    const newTemplate = () => {
        setCustomTemplateEdit({ type: "new" });
    };

    const closeEdit = () => {
        setCustomTemplateEdit(undefined);
    };

    const save = React.useCallback(
        async (customTemplate: CustomTemplate) => {
            try {
                loading.show();
                const savedTemplate = await compositionRoot.templates.save({ template: customTemplate, currentUser });
                closeEdit();
                snackbar.success(i18n.t("Template saved"));
                setCustomTemplates(_.uniqBy([savedTemplate, ...customTemplates], "id"));
            } catch (error) {
                console.error(error);
                snackbar.error(i18n.t("An error ocurred while saving custom template"));
            } finally {
                loading.hide();
            }
        },
        [compositionRoot, currentUser, customTemplates, loading, setCustomTemplates, snackbar]
    );

    const edit = React.useCallback(
        (ids: string[]) => {
            const template = customTemplates.find(row => row.id === ids[0]);
            if (template) setCustomTemplateEdit({ type: "edit", template });
        },
        [customTemplates]
    );

    const deleteTemplates = React.useCallback(
        (ids: string[]) => {
            setWarningDialog({
                title: i18n.t("Delete {{count}} templates", { count: ids.length }),
                description: i18n.t("Are you sure you want to remove the selected templates"),
                action: async () => {
                    loading.show();
                    await promiseMap(ids, id => compositionRoot.templates.delete(id));
                    setSelection([]);
                    setCustomTemplates(_.reject(customTemplates, ({ id }) => ids.includes(id)));
                    loading.hide();
                },
            });
        },
        [compositionRoot.templates, customTemplates, loading, setCustomTemplates]
    );

    const downloadSpreadsheet = React.useCallback(
        async (templateId: string) => {
            const template = customTemplates.find(row => row.id === templateId);
            const row = rows.find(row => row.id === templateId);

            if (template) {
                downloadFile({
                    filename: template.id + ".xlsx",
                    data: await fromBase64(template.file.contents),
                    mimeType: xlsxMimeType,
                });
            } else if (row) {
                compositionRoot.templates.download(api, {
                    type: row.dataFormType,
                    id: row.dataFormId,
                    templateId: getGeneratedTemplateId(row.dataFormType),
                    templateType: "generated",
                    language: "en",
                    settings,
                    populate: false,
                    downloadRelationships: false,
                    splitDataEntryTabsBySection: false,
                    useCodesForMetadata: false,
                    showLanguage: false,
                    showPeriod: false,
                });
            } else {
                snackbar.error(i18n.t("Cannot download spreadsheet for template"));
                return;
            }
        },
        [customTemplates, compositionRoot, rows, snackbar, api, settings]
    );

    const closeWarningDialog = React.useCallback(() => {
        setWarningDialog(null);
    }, []);

    const translations = React.useMemo(getTranslations, []);

    const columns: TableColumn<TemplateRow>[] = [
        { name: "name", text: i18n.t("Name") },
        { name: "dataFormName", text: i18n.t("Data Form") },
        { name: "description", text: i18n.t("Description"), hidden: true },
        {
            name: "dataFormType",
            text: i18n.t("Data Form Type"),
            getValue: row => translations.dataFormTypes[row.dataFormType],
        },
        {
            name: "type",
            text: i18n.t("Type"),
            getValue: row => (row.type === "custom" ? i18n.t("Custom") : i18n.t("Autogenerated")),
        },
        { name: "created", text: i18n.t("Created"), getValue: row => row.created || "-", hidden: true },
        { name: "lastUpdated", text: i18n.t("Last Updated"), getValue: row => row.lastUpdated || "-", hidden: true },
    ];

    const actions: TableAction<TemplateRow>[] = [
        {
            name: "sharing",
            text: i18n.t("Sharing Settings"),
            primary: false,
            onClick: selectedIds => setSettingsState({ type: "open", id: firstOrFail(selectedIds) }),
            icon: <Icon>share</Icon>,
        },
        {
            name: "download_spreadsheet",
            text: i18n.t("Download spreadsheet"),
            primary: false,
            onClick: selectedIds => downloadSpreadsheet(firstOrFail(selectedIds)),
            icon: <Icon>cloud_download</Icon>,
        },
        {
            name: "edit",
            text: i18n.t("Edit"),
            primary: true,
            onClick: edit,
            icon: <Icon>edit</Icon>,
            isActive: rows => rows.length === 1 && rows[0]?.type === "custom",
        },
        {
            name: "delete",
            text: i18n.t("Delete"),
            onClick: deleteTemplates,
            icon: <Icon>delete</Icon>,
            isActive: rows => rows.length === 1 && rows[0]?.type === "custom",
        },
    ];

    const onTableChange = ({ selection }: TableState<TemplateRow>) => {
        setSelection(selection);
    };

    type SettingsState = { type: "closed" } | { type: "open"; id: string };
    const [settingsState, setSettingsState] = useState<SettingsState>({ type: "closed" });

    const closeSettings = React.useCallback(() => {
        setSettingsState({ type: "closed" });
    }, []);

    const classes = useStyles();

    return (
        <React.Fragment>
            {warningDialog && (
                <ConfirmationDialog
                    isOpen={true}
                    title={warningDialog.title}
                    description={warningDialog.description}
                    saveText={i18n.t("Ok")}
                    onSave={() => {
                        if (warningDialog.action) warningDialog.action();
                        setWarningDialog(null);
                    }}
                    onCancel={closeWarningDialog}
                />
            )}

            {settingsState.type === "open" && (
                <TemplatePermissionsDialog
                    onClose={closeSettings}
                    templateId={settingsState.id}
                    settings={settings}
                    onChange={setSettings}
                />
            )}

            {customTemplateEdit && (
                <CustomTemplateEditDialog
                    formMode={customTemplateEdit}
                    customTemplates={customTemplates}
                    onSave={save}
                    onCancel={closeEdit}
                />
            )}

            <ObjectsTable<TemplateRow>
                rows={rows}
                columns={columns}
                actions={actions}
                selection={selection}
                onChange={onTableChange}
                paginationOptions={paginationOptions}
                filterComponents={
                    <React.Fragment key="filters">
                        <SearchBox
                            key="objects-table-search-box"
                            className={classes.searchBox}
                            value={searchText}
                            hintText={i18n.t("Search by name/code")}
                            onChange={search}
                        />
                        <div className={classes.dataFormSelect}>
                            <Select
                                placeholder={i18n.t("Data Form Type")}
                                options={dataFormTypeOptions}
                                onChange={setDataFormTypeFromOption}
                                value={dataFormType}
                                allowEmpty
                                emptyLabel={i18n.t("All")}
                            />
                        </div>

                        <div className={classes.createTemplateButton}>
                            <Button variant="contained" color="primary" onClick={newTemplate} disableElevation>
                                {i18n.t("Create template")}
                            </Button>
                        </div>
                    </React.Fragment>
                }
            />
        </React.Fragment>
    );
}

function buildCustomTemplateRow(
    dataFormsById: _.Dictionary<DataForm>,
    customTemplates: CustomTemplate[]
): TemplateRow[] {
    const templatesByDataForm = _(customTemplates)
        .groupBy(template => (template.dataFormId.type === "value" ? template.dataFormId.id : undefined))
        .value();

    const defaultCustomTemplates = customTemplates.filter(t => t.isDefault);

    const rows = _(dataFormsById)
        .flatMap((dataForm, dataFormId) => {
            const customTemplates = templatesByDataForm[dataFormId];

            const templatesToShow = _(customTemplates)
                .map(template => buildRowFromCustomTemplate(template, dataForm))
                .compact()
                .value();

            const autogeneratedRow: TemplateRow = {
                type: "autogenerated",
                isDefault: false,
                name: dataForm.name,
                id: dataForm.id,
                description: "",
                created: "",
                lastUpdated: "",
                dataFormId: dataForm.id,
                dataFormType: dataForm.type,
                dataFormName: dataForm.name,
                showLanguage: false,
                showPeriod: false,
            };

            return _.compact([...templatesToShow, autogeneratedRow]);
        })
        .concat(_.compact(defaultCustomTemplates.map(t => buildRowFromCustomTemplate(t))))
        .value();

    return rows;
}

function buildRowFromCustomTemplate(customTemplate: CustomTemplate, dataForm?: DataForm): TemplateRow | undefined {
    const dataFormType = customTemplate.dataFormType.type === "value" ? customTemplate.dataFormType.id : undefined;
    if (!dataFormType) return;

    return {
        type: "custom",
        isDefault: customTemplate.isDefault,
        id: customTemplate.id,
        name: customTemplate.name,
        description: customTemplate.description,
        created: customTemplate.created
            ? `${customTemplate.created.user.username} (${formatDate(customTemplate.created.timestamp)})`
            : "-",
        lastUpdated: customTemplate.lastUpdated
            ? `${customTemplate.lastUpdated.user.username} (${formatDate(customTemplate.lastUpdated.timestamp)})`
            : "-",
        dataFormType: dataFormType,
        dataFormId: dataForm ? dataForm.id : "ALL",
        dataFormName: dataForm ? dataForm.name : i18n.t("ALL"),
        showLanguage: customTemplate.showLanguage || false,
        showPeriod: customTemplate.showPeriod || false,
    };
}
function formatDate(timestamp: string): string {
    return moment(timestamp).format("YYYY-MM-DD HH:mm");
}

const paginationOptions: PaginationOptions = {
    pageSizeOptions: [10, 20],
    pageSizeInitialValue: 10,
};

const useStyles = makeStyles({
    createTemplateButton: { marginLeft: 20 },
    dataFormSelect: { width: 150, marginLeft: 20, marginTop: -9 },
    searchBox: { maxWidth: "500px", width: "30%", marginLeft: 20 },
});

function useFilters(allRows: TemplateRow[]) {
    const [searchText, search] = React.useState("");

    const dataFormTypeOptions = React.useMemo(() => {
        return [
            { value: "dataSets", label: i18n.t("Data Set") },
            { value: "programs", label: i18n.t("Event Program") },
            { value: "trackerPrograms", label: i18n.t("Tracker Program") },
        ];
    }, []);

    const [dataFormType, setDataFormType] = React.useState<DataFormType>();

    const setDataFormTypeFromOption = React.useCallback<SelectProps["onChange"]>(option => {
        if (!option.value) {
            setDataFormType(undefined);
        } else if (isValueInUnionType(option.value, dataFormTypes)) {
            setDataFormType(option.value);
        }
    }, []);

    const rowsByText = React.useMemo(() => {
        const text = searchText.toLowerCase().trim();
        return text
            ? allRows.filter(row => row.id.toLowerCase().includes(text) || row.name.toLowerCase().includes(text))
            : allRows;
    }, [allRows, searchText]);

    const rows = React.useMemo(() => {
        return dataFormType ? rowsByText.filter(row => row.dataFormType === dataFormType) : rowsByText;
    }, [dataFormType, rowsByText]);

    return { rows, searchText, search, dataFormTypeOptions, dataFormType, setDataFormTypeFromOption };
}
